using System;
using System.Windows.Threading;
using AuroraDialogEnhancer.Backend.External;

namespace AuroraDialogEnhancer.Backend.Hooks.Process;

public abstract class ProcessHookBase
{
    /// <summary>
    /// The callback function is not mapped into the address space of the process that generates the event. Because the hook function is called across process boundaries, the system must queue events. Although this method is asynchronous, events are guaranteed to be in sequential order. For more information, see <see href="https://learn.microsoft.com/en-us/windows/desktop/WinAuto/out-of-context-hook-functions">Out-of-Context Hook Functions</see>.
    /// </summary>
    private const uint WINEVENT_OUTOFCONTEXT   = 0x0000;
    
    /// <summary>
    /// Prevents this instance of the hook from receiving the events that are generated by threads in this process. This flag does not prevent threads from generating events.
    /// </summary>
    private const uint WINEVENT_SKIPOWNPROCESS = 0x0002;
    
    /// <summary>
    /// Prevents this instance of the hook from receiving the events that are generated by the thread that is registering this hook.
    /// </summary>
    private const uint WINEVENT_SKIPOWNTHREAD  = 0x0001;
    
    private IntPtr _handle;
    private NativeMethods.WinEventDelegate _winEventDelegate;
    protected virtual uint ProcessId => 0;
    public virtual uint EventMin => 0x0000;
    public virtual uint EventMax => 0x0000;

    protected ProcessHookBase()
    {
        _winEventDelegate = EventHookCallback;
    }
    
    public virtual void SetWinEventHook(NativeMethods.WinEventDelegate winEventDelegate)
    {
        _winEventDelegate = winEventDelegate;
        SetWinEventHook();
    }
    
    public virtual void SetWinEventHook()
    {
        System.Windows.Application.Current.Dispatcher.Invoke(() =>
        {
            _handle = NativeMethods.SetWinEventHook(
                EventMin, 
                EventMax,
                IntPtr.Zero,
                _winEventDelegate,
                ProcessId, 
                0,
                WINEVENT_OUTOFCONTEXT | WINEVENT_SKIPOWNPROCESS | WINEVENT_SKIPOWNTHREAD);
        }, DispatcherPriority.Normal);
    }
    
    protected virtual void EventHookCallback(IntPtr hWinEventHook, uint eventType, IntPtr hwnd, int idObject, int idChild, uint dwEventThread, uint dwmsEventTime)
    {
    }

    public virtual void UnhookWinEvent()
    {
        if (_handle == IntPtr.Zero) return;

        System.Windows.Application.Current.Dispatcher.Invoke(() =>
        {
            NativeMethods.UnhookWinEvent(_handle);
            _handle = IntPtr.Zero;
        }, DispatcherPriority.Normal);
    }
}
